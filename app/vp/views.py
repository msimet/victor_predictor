"""
views.py: generate HTML pages for the VictorPredictor app using Flask.
"""

import os
from flask import render_template
from flask import request
from flask import Markup
import pandas as pd
import psycopg2
import numpy as np
from vp import app

username = os.environ['rds_username']
password = os.environ['rds_password']
host = os.environ['rds_host']
dbname = 'goodreads_db'
port = '5432'

con = None
con = psycopg2.connect(database=dbname, user=username, host=host, password=password)

max_nrows = 25

# These next few rows describe parameters of the checkboxes users can select on the app homepage,
# so we can dynamically generate the boxes
# if we re-train and find new or different genre sets (for example).
# These genre summary words are generated by hand from the words most associated with each genre
genres = ['Hard SF', "Space SF", 'Dystopia', 'High fantasy', 'Adventure', 'Urban fantasy', 'Literary', 'Mystery/horror',
          'Paranormal romance', "Fantasy romance"]
genre_indices = [2, 6, 3, 0, 9, 7, 8, 4, 1, 5]
genredict = [{'index': i, 'name': g, "checked": "checked"} for i, g in zip(genre_indices, genres)]
levels = ['Adult', 'YA', 'Children']
leveldict = [{'index': l, 'name': l, "checked": "checked"} for l in levels]
ignore = ['Ignore author characteristics',
          'Ignore reading levels',
          'Include short story collections and comics']
ignore_alts = ["Authors who have won or been nominated for an award are more likely to win or be nominated in the "
               + "future. If you want to find something new, check this box to ignore this effect.",
               "YA and children's books are less likely to win awards aimed at adult fiction. "
               + "Check this box to ignore this effect.",
               "Short story collections and graphic novels are not eligible for best novel awards, but some of them "
               + "appear in our data set. By default we don't show them, but if you check this box we will--but note "
               + "that our data set for these formats is not complete!"]
ignoredict = [{'index': ig.split()[1], "name": ig, "checked": "", "alt": alt}
              for ig, alt in zip(ignore, ignore_alts)]

def get_links(df, name, main_url, search_url):
    """  Replace a column "identifier_value{name}" in a dataframe with the URL of a link. If the identifier value is not
         None, then return a direct link to that website. Otherwise, check for an ISBN and use that (except for
         Audible), and otherwise run a search for the title and authors.

         This function modifies `df` **in-place** and nothing is returned.

         Parameters:
         -----------
         df: pd.DataFrame
            A DataFrame containing the works to be displayed
         name: str
            The name of the site ('amazon', 'goodreads', 'bn', 'audible', 'oclc'
         main_url: str
            The url for the site when the identifier is known
         search_url: str
            The url for the site when a search is to be performed
    """
    mask = df[f'identifier_value_{name}'].isna()
    df[f'identifier_value_{name}'][~mask] = df[f'identifier_value_{name}'][~mask].apply(lambda x: main_url.format(x))
    if 'audible' not in main_url:
        mask = df[f'identifier_value_{name}'].isna() & (df['pub_isbn'] != '-1')
        df[f'identifier_value_{name}'][mask] = df['pub_isbn'][mask].apply(lambda x: search_url.format(x))
    mask = df[f'identifier_value_{name}'].isna()
    df[f'identifier_value_{name}'][mask] = df.apply(lambda x: search_url.format("{} {}".format(x.title, x.author)),
                                                    axis=1)

@app.route('/')
@app.route('/index.html')
def index():
    """
    Produce the only page on the VictorPredictor app: index.html, which displays the (possibly sorted, possibly
    filtered) results of SQL queries for several different types of book scores.

    Behavior is controlled through forms submitted using the GET method, including: genres, that limits the genres
    shown; levels, that controls reading levels (adult, YA, children's); ignore, that sets some marginalization
    options for the computation of the VictorPredictor score; sortby and direction, that control sorting; and
    current_page, that controls pagination. These are separate forms, so the current value gets passed as hidden
    form values in the other forms so we maintain e.g. the genre keyword when we change sorting.  The forms are all
    dynamically generated by this function through the render template call.

    Returns
    -------
    The result of a call to render_template including book data from the SQL query and form input options.
    """
    # The three sets of checkboxes. Also generate "hidden" input types, since these go into two different forms
    # and we don't want to erase the other search when we issue a new one.
    do_genres = request.args.getlist('genres')
    do_levels = request.args.getlist('levels')
    do_ignore = request.args.getlist('ignore')
    hidden_ignore = [{'name': 'ignore', 'value': ig} for ig in do_ignore]
    hidden_genrelevels = ([{'name': 'genres', 'value': ge} for ge in do_genres]
                          + [{'name': 'levels', 'value': le} for le in do_levels])


    # All three kinds of checkboxes can modify the SQL query. Here we build up different parts of the WHERE clause.
    # Treat all boxes checked & no boxes checked exactly the same, to minimize errors.
    if len(do_genres) < len(genres) and len(do_genres) > 0:
        genre_retlist = [{'index': gd['index'],
                          'name': gd['name'],
                          'checked': 'checked' if f'{gd["index"]}' in do_genres else ''}
                         for gd in genredict]
        do_genres = [f'is_genre{dg}=True' for dg in do_genres if int(dg) in genre_indices]
    else:
        do_genres = []
        genre_retlist = genredict

    if len(do_levels) < len(levels) and len(do_levels) > 0:
        level_retlist = [{'index': ld['index'],
                          'name': ld['name'],
                          'checked': 'checked' if ld["index"] in do_levels else ''}
                         for ld in leveldict]
        dl = []
        # Based on histograms, 0.1 is a good level for things that are actually YA or children's
        # and not just a few erroneous tags.
        if 'Adult' in do_levels:
            dl += ['(1.0*children/(nreviews+1) < 0.1 AND 1.0*ya/(nreviews+1) < 0.1)']
        if 'YA' in do_levels:
            dl += ['1.0*ya/(nreviews+1) >= 0.1']
        if 'Children' in do_levels:
            dl += ['1.0*children/(nreviews+1) >= 0.1']
        do_levels = dl
    else:
        do_levels = []
        level_retlist = leveldict

    scoretype = 'pred_score'
    if len(do_ignore) > 0:
        idict = ignoredict.copy()
        if 'reading' in do_ignore:
            scoretype += '_readinglevel'
            idict[1] = {'index': idict[1]['index'], 'name': idict[1]['name'],
                        'checked': 'checked', 'alt': idict[1]['alt']}
        if 'author' in do_ignore:
            scoretype += '_author'
            idict[0] = {'index': idict[0]['index'], 'name': idict[0]['name'],
                        'checked': 'checked', 'alt': idict[0]['alt']}
    else:
        idict = ignoredict

    # Only show this year's data!
    where_clause = 'WHERE pubyear=2019'

    if len(do_genres) > 0:
        where_clause += ' AND (' + ' OR '.join(do_genres) +')'
    if len(do_levels) > 0:
        where_clause += ' AND (' + ' OR '.join(do_levels) +')'
    if 'short' not in do_ignore and False:
        where_clause += "AND comics!=0 AND short_stories!=0 AND pub_ctype!='COLLECTION' "
        where_clause += "AND pub_ctype!='OMNIBUS' AND title_storylen!='short story'"
        where_clause += "AND title_storylen!='novelette' AND title_graphic!='Yes'"

    sql_query = (f"SELECT title, all_authors as author, author_lastname, {scoretype} as score, title_id, "+
                 f"identifier_value_amazon, identifier_value_bn, identifier_value_goodreads, identifier_value_audible, "
                 f"identifier_value_oclc, pub_isbn FROM works_flask {where_clause}")
    query_results = pd.read_sql_query(sql_query, con).sort_values('score', ascending=False)
    query_results = pd.concat([query_results[query_results['title_id'] == -1],
                               query_results.drop_duplicates('title_id')]
                              ).drop_duplicates()
    query_results['color'] = ["hsl(214, {:.2f}%, 50%)".format(score*100) for score in query_results['score']]
    query_results['link'] = ['']*len(query_results)

    sortby = request.args.get('sortby', 'score')
    direction = request.args.get('direction', 'desc')
    if sortby == 'score':
        if direction == 'desc':
            score_sort_direction = 'asc'
            score_arrow = Markup(" &#9662;")
        else:
            score_sort_direction = 'desc'
            score_arrow = Markup(" &#9652;")
        sort_key = 'score'
    else:
        score_sort_direction = "desc"
        score_arrow = ''
    if sortby == 'title':
        if direction == 'desc':
            title_sort_direction = 'asc'
            title_arrow = Markup(" &#9652;")
        else:
            title_sort_direction = 'desc'
            title_arrow = Markup(" &#9662;")
        sort_key = 'title'
    else:
        title_sort_direction = 'asc'
        title_arrow = ""
    if sortby == 'author':
        if direction == 'desc':
            author_sort_direction = 'asc'
            author_arrow = Markup(" &#9652;")
        else:
            author_sort_direction = 'desc'
            author_arrow = Markup(" &#9662;")
        sort_key = 'author_lastname'
    else:
        author_sort_direction = 'asc'
        author_arrow = ""

    sort_dir = (direction == 'asc')
    urlkeys = ['{}={}'.format(key, item) for key, item in request.args.items(multi=True)
               if key not in ("current_page", "direction", 'sortby')]
    title_urlkeys = urlkeys + ['sortby=title&direction={}'.format(title_sort_direction)]
    author_urlkeys = urlkeys + ['sortby=author&direction={}'.format(author_sort_direction)]
    score_urlkeys = urlkeys + ['sortby=score&direction={}'.format(score_sort_direction)]
    title_url = 'index.html?' + '&'.join(title_urlkeys)
    author_url = 'index.html?' + '&'.join(author_urlkeys)
    score_url = 'index.html?' + '&'.join(score_urlkeys)

    query_results['author_lastname'] = query_results['author_lastname'].str.lower()
    query_results = query_results.sort_values(by=sort_key, ascending=sort_dir)
    nrows = len(query_results)
    curr_page = int(request.args.get('current_page', 1))
    if nrows > max_nrows:
        npages = int(np.ceil(1.0*nrows/max_nrows))
        curr_page = max([1, min([npages, curr_page])])
        query_results = query_results[max_nrows*(curr_page-1):max_nrows*curr_page]
    else:
        npages = 1
    urlkeys = ['{}={}'.format(key, item) for key, item in request.args.items(multi=True) if key != "current_page"]
    next_urlkeys = urlkeys + ['current_page={}'.format(curr_page+1)]
    prev_urlkeys = urlkeys + ['current_page={}'.format(curr_page-1)]
    next_url = 'index.html?' + '&'.join(next_urlkeys)
    prev_url = 'index.html?' + '&'.join(prev_urlkeys)

    # Do this last because it's a little slow running by rows--this way we do at most max_nrows
    get_links(query_results, 'amazon', "https://www.amazon.com/dp{}", "https://www.amazon.com/s?k={}")
    get_links(query_results, 'bn', "http://www.barnesandnoble.com/s/{}", "http://www.barnesandnoble.com/s/{}")
    get_links(query_results, 'goodreads', "http://www.goodreads.com/book/show/{}",
              "http://www.goodreads.com/search?q={}")
    get_links(query_results, 'audible', "https://www.audible.com/pd/{}",
              "https://www.audible.com/search?keywords={}")
    get_links(query_results, 'oclc', "http://www.worldcat.org/oclc/{}",
              "https://www.worldcat.org/search?qt=worldcat_org_all&q={}")

    return render_template('index.html',
                           books=query_results.to_dict('records'),
                           genres=genre_retlist,
                           levels=level_retlist,
                           ignore=idict,
                           curr_page=curr_page,
                           npages=npages,
                           prev_url=prev_url,
                           next_url=next_url,
                           title_url=title_url, title_arrow=title_arrow,
                           author_url=author_url, author_arrow=author_arrow,
                           score_url=score_url, score_arrow=score_arrow,
                           hidden_ignore=hidden_ignore, hidden_genrelevels=hidden_genrelevels)
